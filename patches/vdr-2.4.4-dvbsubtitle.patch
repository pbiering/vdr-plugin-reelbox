diff --git a/dvbsubtitle.c b/dvbsubtitle.c
index 5e5139ff..e89aaec8 100644
--- a/dvbsubtitle.c
+++ b/dvbsubtitle.c
@@ -993,7 +993,9 @@ public:
   int64_t Pts(void) const { return pts; }
   bool Pending(void) { return pending; }
   cSubtitleObjects *Objects(void) { return &objects; }
-  tArea *GetAreas(int &NumAreas, double FactorX, double FactorY);
+  tArea *GetAreas(int &NumAreas);
+  tArea *GetAreaCombined(const int NumAreas, const tArea *a);
+  tArea *GetAreaOsd(const int NumAreas, const tArea *a, const double FactorX, const double FactorY);
   cSubtitleObject *GetObjectById(int ObjectId, bool New = false);
   cSubtitleClut *GetClutById(int ClutId, bool New = false);
   cSubtitleRegion *GetRegionById(int RegionId, bool New = false);
@@ -1077,7 +1079,62 @@ void cDvbSubtitlePage::ParsePgs(int64_t Pts, cBitStream &bs)
   pending = true;
 }
 
-tArea *cDvbSubtitlePage::GetAreas(int &NumAreas, double FactorX, double FactorY)
+tArea *cDvbSubtitlePage::GetAreaOsd(const int NumAreas, const tArea *a, const double FactorX, const double FactorY)
+{
+  if (NumAreas == 0)
+    return NULL; // nothing to do
+
+  tArea *AreaOsd = new tArea[1]; // only 1 scaled OSD area
+  tArea *ao = AreaOsd;
+
+  ao->x1  = int(round(FactorX * a->x1)    );
+  ao->x2  = int(round(FactorX * a->x2) - 1);
+  ao->y1  = int(round(FactorY * a->y1)    );
+  ao->y2  = int(round(FactorY * a->y2) - 1);
+  ao->bpp = a->bpp;
+  while ((ao->Width() & 3) != 0)
+    ao->x2++; // aligns width to a multiple of 4, so 2, 4 and 8 bpp will work
+
+  return AreaOsd;
+};
+
+
+tArea *cDvbSubtitlePage::GetAreaCombined(const int NumAreas, const tArea *a)
+{
+  if (NumAreas == 0)
+    return NULL; // nothing to do
+
+  int x1min = -1, x2max = -1, y1min = -1, y2max = -1, bpp = -1;
+  for (int i = 0; i < NumAreas; i++) {
+    if (i == 0) {
+      // init
+      x1min = a[i].x1;
+      x2max = a[i].x2;
+      y1min = a[i].y1;
+      y2max = a[i].y2;
+      bpp   = a[i].bpp;
+    } else {
+      if (x1min > a[i].x1 ) x1min = a[i].x1 ;
+      if (x2max < a[i].x2 ) x2max = a[i].y2 ;
+      if (y1min > a[i].y1 ) y1min = a[i].y1 ;
+      if (y2max < a[i].y2 ) y2max = a[i].y2 ;
+      if (bpp   < a[i].bpp) bpp   = a[i].bpp;
+    };
+  };
+
+  tArea *AreaCombined = new tArea[1]; // only 1 combined area
+  tArea *ac = AreaCombined;
+
+  ac->x1  = x1min;
+  ac->x2  = x2max;
+  ac->y1  = y1min;
+  ac->y2  = y2max;
+  ac->bpp = bpp;
+
+  return AreaCombined;
+};
+
+tArea *cDvbSubtitlePage::GetAreas(int &NumAreas)
 {
   if (regions.Count() > 0) {
      NumAreas = regionRefs.Count();
@@ -1085,13 +1142,11 @@ tArea *cDvbSubtitlePage::GetAreas(int &NumAreas, double FactorX, double FactorY)
      tArea *a = Areas;
      for (cSubtitleRegionRef *srr = regionRefs.First(); srr; srr = regionRefs.Next(srr)) {
          if (cSubtitleRegion *sr = GetRegionById(srr->RegionId())) {
-            a->x1 = int(round(FactorX * srr->RegionHorizontalAddress()));
-            a->y1 = int(round(FactorY * srr->RegionVerticalAddress()));
-            a->x2 = int(round(FactorX * (srr->RegionHorizontalAddress() + sr->RegionWidth() - 1)));
-            a->y2 = int(round(FactorY * (srr->RegionVerticalAddress() + sr->RegionHeight() - 1)));
+            a->x1 = srr->RegionHorizontalAddress();
+            a->y1 = srr->RegionVerticalAddress();
+            a->x2 = srr->RegionHorizontalAddress() + sr->RegionWidth() - 1;
+            a->y2 = srr->RegionVerticalAddress() + sr->RegionHeight() - 1;
             a->bpp = sr->RegionDepth();
-            while ((a->Width() & 3) != 0)
-                  a->x2++; // aligns width to a multiple of 4, so 2, 4 and 8 bpp will work
             }
          else
             a->x1 = a->y1 = a->x2 = a->y2 = a->bpp = 0;
@@ -1219,11 +1274,13 @@ private:
   int timeout;
   tArea *areas;
   int numAreas;
+  tArea *areaCombined;
+  tArea *areaOsd;
   double osdFactorX;
   double osdFactorY;
   cVector<cBitmap *> bitmaps;
 public:
-  cDvbSubtitleBitmaps(int State, int64_t Pts, int Timeout, tArea *Areas, int NumAreas, double OsdFactorX, double OsdFactorY);
+  cDvbSubtitleBitmaps(int State, int64_t Pts, int Timeout, tArea *Areas, int NumAreas, double OsdFactorX, double OsdFactorY, tArea *AreaCombined, tArea *AreaOsd);
   ~cDvbSubtitleBitmaps();
   int State(void) { return state; }
   int64_t Pts(void) { return pts; }
@@ -1234,13 +1291,15 @@ public:
   void DbgDump(int WindowWidth, int WindowHeight);
   };
 
-cDvbSubtitleBitmaps::cDvbSubtitleBitmaps(int State, int64_t Pts, int Timeout, tArea *Areas, int NumAreas, double OsdFactorX, double OsdFactorY)
+cDvbSubtitleBitmaps::cDvbSubtitleBitmaps(int State, int64_t Pts, int Timeout, tArea *Areas, int NumAreas, double OsdFactorX, double OsdFactorY, tArea *AreaCombined, tArea *AreaOsd)
 {
   state = State;
   pts = Pts;
   timeout = Timeout;
   areas = Areas;
   numAreas = NumAreas;
+  areaCombined = AreaCombined;
+  areaOsd = AreaOsd;
   osdFactorX = OsdFactorX;
   osdFactorY = OsdFactorY;
 }
@@ -1248,6 +1307,8 @@ cDvbSubtitleBitmaps::cDvbSubtitleBitmaps(int State, int64_t Pts, int Timeout, tA
 cDvbSubtitleBitmaps::~cDvbSubtitleBitmaps()
 {
   delete[] areas;
+  delete[] areaCombined;
+  delete[] areaOsd;
   for (int i = 0; i < bitmaps.Size(); i++)
       delete bitmaps[i];
 }
@@ -1260,25 +1321,26 @@ void cDvbSubtitleBitmaps::AddBitmap(cBitmap *Bitmap)
 void cDvbSubtitleBitmaps::Draw(cOsd *Osd)
 {
   bool Scale = !(DoubleEqual(osdFactorX, 1.0) && DoubleEqual(osdFactorY, 1.0));
-  bool AntiAlias = true;
+  bool AntiAlias = Setup.AntiAlias;
   if (Scale && osdFactorX > 1.0 || osdFactorY > 1.0) {
      // Upscaling requires 8bpp:
-     int Bpp[MAXOSDAREAS];
-     for (int i = 0; i < numAreas; i++) {
-         Bpp[i] = areas[i].bpp;
-         areas[i].bpp = 8;
-         }
-     if (Osd->CanHandleAreas(areas, numAreas) != oeOk) {
-        for (int i = 0; i < numAreas; i++)
-            areas[i].bpp = Bpp[i];
+     int Bpp;
+     Bpp = areaOsd[0].bpp;
+     areaOsd[0].bpp = 8;
+     if (Osd->CanHandleAreas(areaOsd, 1) != oeOk) {
+        areaOsd[0].bpp = Bpp;
         AntiAlias = false;
         }
      }
-  if (State() == 0 || Osd->SetAreas(areas, numAreas) == oeOk) {
+  if (State() == 0 || Osd->SetAreas(areaOsd, 1) == oeOk) {
+     cBitmap combined(areaCombined[0].Width(), areaCombined[0].Height(), areaCombined[0].bpp);
+     combined.SetOffset(areaCombined[0].x1, areaCombined[0].y1);
      for (int i = 0; i < bitmaps.Size(); i++) {
+         // merge bitmaps into combined
          cBitmap *b = bitmaps[i];
-         Osd->DrawScaledBitmap(int(round(b->X0() * osdFactorX)), int(round(b->Y0() * osdFactorY)), *b, osdFactorX, osdFactorY, AntiAlias);
+         combined.DrawBitmap(b->X0(), b->Y0(), *b);
          }
+     Osd->DrawScaledBitmap(int(round(combined.X0() * osdFactorX)), int(round(combined.Y0() * osdFactorY)), combined, osdFactorX, osdFactorY, AntiAlias);
      Osd->Flush();
      }
 }
@@ -1734,25 +1796,27 @@ void cDvbSubtitleConverter::FinishPage(cDvbSubtitlePage *Page)
   if (!AssertOsd())
      return;
   int NumAreas;
-  tArea *Areas = Page->GetAreas(NumAreas, osdFactorX, osdFactorY);
+  tArea *Areas = Page->GetAreas(NumAreas);
+  if (Areas == NULL) return; // nothing todo
+  tArea *AreaCombined = Page->GetAreaCombined(NumAreas, Areas);
+  tArea *AreaOsd = Page->GetAreaOsd(NumAreas, AreaCombined, osdFactorX, osdFactorY);
+  if (AreaOsd == NULL) return; // nothing todo
   int Bpp = 8;
   bool Reduced = false;
-  while (osd && osd->CanHandleAreas(Areas, NumAreas) != oeOk) {
+  while (osd && osd->CanHandleAreas(AreaOsd, 1) != oeOk) {
         dbgoutput("CanHandleAreas: %d<br>\n", osd->CanHandleAreas(Areas, NumAreas));
         int HalfBpp = Bpp / 2;
         if (HalfBpp >= 2) {
-           for (int i = 0; i < NumAreas; i++) {
-               if (Areas[i].bpp >= Bpp) {
-                  Areas[i].bpp = HalfBpp;
-                  Reduced = true;
-                  }
-               }
+           if (AreaOsd[0].bpp >= Bpp) {
+               AreaOsd[0].bpp = HalfBpp;
+               Reduced = true;
+	   };
            Bpp = HalfBpp;
            }
         else
            return; // unable to draw bitmaps
         }
-  cDvbSubtitleBitmaps *Bitmaps = new cDvbSubtitleBitmaps(Page->PageState(), Page->Pts(), Page->PageTimeout(), Areas, NumAreas, osdFactorX, osdFactorY);
+  cDvbSubtitleBitmaps *Bitmaps = new cDvbSubtitleBitmaps(Page->PageState(), Page->Pts(), Page->PageTimeout(), Areas, NumAreas, osdFactorX, osdFactorY, AreaCombined, AreaOsd);
   bitmaps->Add(Bitmaps);
   for (int i = 0; i < NumAreas; i++) {
       if (cSubtitleRegionRef *srr = Page->GetRegionRefByIndex(i)) {
